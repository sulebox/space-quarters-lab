<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

    // ---- Setup ----
    const $ = (id) => document.getElementById(id);
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xc0c6c8); 

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    $('app').appendChild(renderer.domElement);

    // Camera
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 100);
    const updateCamera = () => {
      const aspect = window.innerWidth / window.innerHeight;
      const zoom = window.innerWidth < 800 ? 14 : 20; 
      const s = zoom;
      camera.left = -s * aspect / 2; camera.right = s * aspect / 2;
      camera.top = s / 2; camera.bottom = -s / 2;
      camera.position.set(20, 20, 20);
      camera.lookAt(0, 0, 0);
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', updateCamera);
    updateCamera();

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
    scene.add(ambientLight);
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); 
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.1); 
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);
    const spot = new THREE.SpotLight(0x3498db, 5, 20, 0.5, 0.5, 1);
    spot.position.set(-6, 8, -2);
    scene.add(spot);

    // ---- Lab Environment ----
    const matFloor = new THREE.MeshStandardMaterial({ color: 0x7f8c8d, roughness: 0.7 });
    const matWall = new THREE.MeshStandardMaterial({ color: 0xecf0f1, roughness: 0.5 }); 
    const matMetal = new THREE.MeshStandardMaterial({ color: 0x546e7a, metalness: 0.7, roughness: 0.2 });
    const matDark = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.6 }); 
    const matGlass = new THREE.MeshPhysicalMaterial({ color: 0xaaccff, transmission: 0.9, opacity: 0.5, transparent: true, roughness: 0.1 });

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(24, 24), matFloor);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const wallBack = new THREE.Mesh(new THREE.BoxGeometry(24, 6, 0.5), matWall);
    wallBack.position.set(0, 3, -8);
    wallBack.receiveShadow = true;
    scene.add(wallBack);
    
    const wallLeft = new THREE.Mesh(new THREE.BoxGeometry(0.5, 6, 16), matWall);
    wallLeft.position.set(-12, 3, 0);
    wallLeft.receiveShadow = true;
    scene.add(wallLeft);

    const weldTable = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 2.5), matMetal);
    weldTable.position.set(-8, 0.75, -2);
    weldTable.castShadow = true;
    scene.add(weldTable);
    const armBase = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.5), new THREE.MeshStandardMaterial({color:0xe67e22, roughness:0.4}));
    armBase.position.set(-8, 1.75, -2);
    scene.add(armBase);
    const WELDING_POS = new THREE.Vector3(-6.5, 0, -2);

    const xrayMachine = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 4, 32), matMetal);
    xrayMachine.rotation.z = Math.PI / 2;
    xrayMachine.position.set(8, 2.2, -2);
    xrayMachine.castShadow = true;
    scene.add(xrayMachine);
    const xrayBed = new THREE.Mesh(new THREE.BoxGeometry(5, 0.2, 1.5), matDark);
    xrayBed.position.set(8, 1.5, -2);
    scene.add(xrayBed);
    const XRAY_POS = new THREE.Vector3(5, 0, -2);

    const vacuumChamber = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), new THREE.MeshStandardMaterial({color:0x95a5a6, metalness:0.8, roughness:0.1}));
    vacuumChamber.position.set(0, 1.8, -6);
    scene.add(vacuumChamber);
    const vacuumBase = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 1.8), matDark);
    vacuumBase.position.set(0, 0.9, -6);
    scene.add(vacuumBase);
    const VACUUM_POS = new THREE.Vector3(0, 0, -3.5);

    const table = new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 2), new THREE.MeshStandardMaterial({color:0xe67e22, roughness:0.5}));
    table.position.set(0, 0.6, 2);
    table.castShadow = true;
    scene.add(table);
    const box1 = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.4,0.6), new THREE.MeshStandardMaterial({color:0xf1c40f, roughness:0.5}));
    box1.position.set(-0.5, 1.4, 2); scene.add(box1);
    const SNACK_POS = new THREE.Vector3(0, 0, 4);

    const toiletWall = new THREE.Mesh(new THREE.BoxGeometry(3, 5, 0.2), matWall);
    toiletWall.position.set(10.5, 2.5, 5);
    scene.add(toiletWall);
    const toiletDoor = new THREE.Mesh(new THREE.BoxGeometry(0.2, 5, 3), matGlass);
    toiletDoor.position.set(9, 2.5, 6.5);
    scene.add(toiletDoor);
    const TOILET_POS = new THREE.Vector3(10, 0, 7);

    // ---- Character Logic ----
    const gltfLoader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    gltfLoader.setDRACOLoader(draco);

    const chars = {}; 
    
    // アクション定義
    const ACTIONS = {
      WELD:  { pos: WELDING_POS, msg: '溶接しよっと' },
      XRAY:  { pos: XRAY_POS, msg: 'X線みよっと' },
      VACUUM:{ pos: VACUUM_POS, msg: '真空チャンバーみよっと' },
      SNACK: { pos: SNACK_POS, msg: 'お菓子たべよっと' },
      TOILET:{ pos: TOILET_POS, msg: 'トイレ行こっと' },
      IDLE:  { msg: 'ちょっと考えごと' }, 
      STOP:  { msg: 'ちょっとつかれた' },
      CHECK: { msg: '周囲をチェック中...ブイン' } 
    };

    // キャラ設定
    const CHAR_CONFIG = {
      zawa: { 
        url: 'zawa.glb', 
        type: 'human',
        role: 'welding',
        tasks: ['WELD', 'SNACK', 'TOILET'],
        color: 0x3498db 
      },
      guchi: { 
        url: 'guchi.glb', 
        type: 'human',
        role: 'xray',
        tasks: ['XRAY', 'SNACK', 'TOILET'],
        color: 0x2ecc71 
      },
      sq: { 
        url: 'sq.glb', 
        type: 'robot',
        role: 'vacuum',
        tasks: ['VACUUM', 'CHECK', 'CHECK'],
        color: 0xe74c3c 
      }
    };

    const toiletQueue = [];
    let toiletUser = null;

    function updateBubble(char, text) {
      if (!char.userData.bubble) {
        const el = document.createElement('div');
        el.className = 'bubble';
        document.body.appendChild(el);
        char.userData.bubble = el;
      }
      const el = char.userData.bubble;
      el.textContent = text;
      el.style.opacity = text ? 1 : 0;
    }

    function updateBubblePos(char) {
      if (!char.userData.bubble || char.userData.bubble.style.opacity == 0) return;
      const offset = char.userData.config.type === 'robot' ? 1.5 : 1.8; // バブル位置も少し下げ
      const pos = char.position.clone().add(new THREE.Vector3(0, offset, 0)).project(camera);
      const x = (pos.x * .5 + .5) * window.innerWidth;
      const y = (-(pos.y * .5) + .5) * window.innerHeight;
      char.userData.bubble.style.left = `${x}px`;
      char.userData.bubble.style.top = `${y}px`;
    }

    function getRandomLabPos() {
        return new THREE.Vector3((Math.random() - 0.5) * 18, 0, (Math.random() - 0.5) * 12 - 2);
    }

    function pickNextAction(char) {
      const conf = CHAR_CONFIG[char.userData.name];
      const taskKey = conf.tasks[Math.floor(Math.random() * conf.tasks.length)];
      
      // トイレロジック
      if (taskKey === 'TOILET') {
          if (!toiletUser && toiletQueue.length === 0) {
              toiletUser = char;
              char.userData.targetPos = ACTIONS.TOILET.pos.clone();
              char.userData.state = 'move';
              char.userData.actionType = 'TOILET'; 
              updateBubble(char, 'トイレ行こっと');
          } else {
              toiletQueue.push(char);
              const waitOffset = toiletQueue.length * 1.0; 
              char.userData.targetPos = ACTIONS.TOILET.pos.clone().add(new THREE.Vector3(-waitOffset, 0, 0));
              char.userData.state = 'move_wait'; 
              char.userData.actionType = 'TOILET_WAIT';
              updateBubble(char, 'トイレ空くの待ってる...');
          }
          return;
      }

      const action = ACTIONS[taskKey];
      if (taskKey === 'CHECK') {
          char.userData.targetPos = getRandomLabPos();
      } else {
          char.userData.targetPos = action.pos.clone().add(new THREE.Vector3((Math.random()-0.5), 0, (Math.random()-0.5)));
      }
      
      char.userData.state = 'move';
      char.userData.actionType = taskKey;
      updateBubble(char, action.msg);
    }

    function setAction(char, name) {
        if (!char.userData.mixer || !char.userData.animations) return;
        const current = char.userData.currentAction;
        const action = char.userData.animations[name];
        if (!action) return;
        if (current === action) return;
        if (current) current.fadeOut(0.2);
        action.reset().fadeIn(0.2).play();
        char.userData.currentAction = action;
    }

    async function loadCharacter(name) {
      const conf = CHAR_CONFIG[name];
      try {
        const gltf = await gltfLoader.loadAsync(conf.url);

        // --- Fix 2: アニメーションから「位置移動」を削除 ---
        // これにより、キャラがアニメーションで勝手に前に進まず、
        // 「その場で足踏み」するようになります。
        if (gltf.animations) {
            gltf.animations.forEach(clip => {
                // positionトラック（移動）を除外するフィルタリング
                clip.tracks = clip.tracks.filter(track => !track.name.endsWith('.position'));
            });
        }
        // ------------------------------------------------

        const model = gltf.scene;
        model.traverse(o => {
            if (o.isMesh) {
                o.castShadow = true;
                o.receiveShadow = true;
            }
        });

        // --- Fix 1: サイズの縮小調整 ---
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        let scale = 1;
        
        // 1.8m -> 1.1m 程度に小さく設定
        if (conf.type === 'human') scale = 1.1 / size.y; 
        else scale = 1.2 / size.y; 
        
        model.scale.setScalar(scale);
        // -----------------------------

        let mixer = null;
        let animations = {};
        if (gltf.animations && gltf.animations.length) {
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach(clip => {
                animations[clip.name.toLowerCase()] = mixer.clipAction(clip);
            });
            if (!animations['idle'] && gltf.animations[0]) animations['idle'] = mixer.clipAction(gltf.animations[0]);
            if (!animations['walk'] && gltf.animations[1]) animations['walk'] = mixer.clipAction(gltf.animations[1]);
        }

        const group = new THREE.Group();
        group.add(model);
        group.userData = { 
            name: name, 
            config: conf, 
            state: 'idle', 
            timer: 0,
            mixer: mixer,
            animations: animations,
            currentAction: null,
            velocity: new THREE.Vector3()
        };
        
        group.position.copy(getRandomLabPos());
        scene.add(group);
        chars[name] = group;

        if (mixer) setAction(group, 'idle');
        pickNextAction(group);
        return group;

      } catch (e) {
        console.error(`Failed to load ${conf.url}:`, e);
      }
    }

    await loadCharacter('zawa');
    await loadCharacter('guchi');
    await loadCharacter('sq');

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      const time = clock.elapsedTime;

      // 衝突回避
      const charArray = Object.values(chars);
      for (let i = 0; i < charArray.length; i++) {
          const char = charArray[i];
          const ud = char.userData;
          if (ud.state.startsWith('move')) {
              let separation = new THREE.Vector3();
              let count = 0;
              for (let j = 0; j < charArray.length; j++) {
                  if (i === j) continue;
                  const other = charArray[j];
                  const dist = char.position.distanceTo(other.position);
                  const minDist = 0.8; // 判定距離も少し小さく
                  if (dist < minDist) {
                      const push = char.position.clone().sub(other.position).normalize();
                      push.divideScalar(dist);
                      separation.add(push);
                      count++;
                  }
              }
              if (count > 0) {
                  separation.divideScalar(count).multiplyScalar(dt * 2.0);
                  char.position.add(separation);
              }
          }
      }

      charArray.forEach(char => {
        const ud = char.userData;
        if (ud.mixer) ud.mixer.update(dt);
        
        if (ud.config.type === 'robot' && char.children[0]) {
          char.children[0].position.y = (char.children[0].scale.y * sizeY(char)/2) + Math.sin(time * 3) * 0.1;
          if (ud.state.startsWith('move')) {
               char.rotation.y += dt * 0.5; 
          }
        }

        // 状態ロジック
        if (ud.state === 'move' || ud.state === 'move_wait') {
          if (ud.config.type === 'human') setAction(char, 'walk');

          const dir = ud.targetPos.clone().sub(char.position);
          dir.y = 0;
          const dist = dir.length();
          
          if (dist > 0.1) {
            dir.normalize();
            char.position.add(dir.multiplyScalar(dt * 1.5));
            if (ud.config.type === 'human') {
                const targetRot = Math.atan2(dir.x, dir.z);
                let rotDiff = targetRot - char.rotation.y;
                while (rotDiff > Math.PI) rotDiff -= Math.PI*2;
                while (rotDiff < -Math.PI) rotDiff += Math.PI*2;
                char.rotation.y += rotDiff * dt * 5.0;
            }
          } else {
            if (ud.state === 'move') {
                ud.state = 'action';
                ud.timer = 0;
                if (ud.config.type === 'human') setAction(char, 'idle');
                if (ud.actionType === 'TOILET') updateBubble(char, 'ふぅ...');
                else updateBubble(char, ACTIONS.STOP.msg);
            } else if (ud.state === 'move_wait') {
                ud.state = 'waiting';
                if (ud.config.type === 'human') setAction(char, 'idle');
                updateBubble(char, 'はやく終わらないかな...');
                const lookDir = ACTIONS.TOILET.pos.clone().sub(char.position);
                char.rotation.y = Math.atan2(lookDir.x, lookDir.z);
            }
          }
        } 
        else if (ud.state === 'waiting') {
            if (!toiletUser && toiletQueue[0] === char) {
                toiletQueue.shift(); 
                toiletUser = char; 
                ud.targetPos = ACTIONS.TOILET.pos.clone();
                ud.state = 'move';
                ud.actionType = 'TOILET';
                updateBubble(char, 'やっと空いた！');
            }
        }
        else if (ud.state === 'action') {
          ud.timer += dt;
          if (ud.timer > 5.0) {
              if (ud.actionType === 'TOILET' && toiletUser === char) {
                  toiletUser = null;
              }
              pickNextAction(char);
          }
        } 
        else if (ud.state === 'speaking') {
             ud.timer += dt;
             if (ud.config.type === 'human') setAction(char, 'idle');
             if (ud.config.type === 'robot') char.rotation.y += Math.sin(time * 20) * 0.05;
             if (ud.timer > 8.0) pickNextAction(char);
        }
        
        updateBubblePos(char);
      });
      renderer.render(scene, camera);
    }
    
    function sizeY(obj) {
        const box = new THREE.Box3().setFromObject(obj);
        return box.max.y - box.min.y;
    }

    animate();

    // ---- Chat Logic ----
    const form = $('input-area');
    const input = $('chat-input');
    const log = $('chat-log');

    function addMsg(text, type, name='') {
      const d = document.createElement('div');
      d.className = `msg ${type}`;
      if(name) {
          const n = document.createElement('span');
          n.className='msg name'; n.textContent=name;
          d.appendChild(n);
      }
      d.innerHTML = text.replace(/\n/g, '<br>');
      log.appendChild(d);
      log.scrollTop = log.scrollHeight;
    }

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const txt = input.value.trim();
      if(!txt) return;
      
      addMsg(txt, 'user');
      input.value = '';
      input.disabled = true;

      let responderKey = 'sq'; 
      if (txt.includes('溶接') && !txt.includes('Space Quarters')) responderKey = 'zawa';
      else if (txt.includes('X線') || txt.includes('レントゲン')) responderKey = 'guchi';
      
      const responder = chars[responderKey];
      responder.userData.state = 'speaking';
      responder.userData.timer = 0;
      updateBubble(responder, 'ブイン...');

      try {
        const res = await fetch('/api/chat', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ message: txt, responder: responderKey })
        });
        const data = await res.json();
        
        addMsg(data.reply, 'bot', responderKey.toUpperCase());
        updateBubble(responder, data.reply.substring(0, 10) + '...');
        
      } catch(err) {
        addMsg('（通信エラー ガガッ）', 'bot');
        updateBubble(responder, 'エラー...');
      } finally {
        input.disabled = false;
        input.focus();
      }
    });
  </script>
